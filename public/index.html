<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        <%= htmlWebpackPlugin.options.title %>
    </title>
</head>
<style>
    /* 核心样式：控制文本显示行数 */
    .text-gray-700 {
        width: 500px;

    }

    .clamped {

        display: -webkit-box;
        -webkit-line-clamp: 2;
        /* 默认显示2行 */
        -webkit-box-orient: vertical;
        overflow: hidden;
    }
</style>

<body>
    <div class="max-w-2xl mx-auto">
        <!-- 文本内容 -->
        <p id="textContent" class="clamped text-gray-700 leading-relaxed">
            这是一段示例文本，用于展示简化版的展开/收起功能。当文本内容超过预设的行数时，会自动显示省略号。点击下方的按钮可以切换文本的显示状态，展开查看完整内容或收起以节省空间。这种简单的实现方式适用于大多数需要控制文本显示长度的场景。
        </p>

        <!-- 控制按钮 -->
        <button id="toggleBtn" class="mt-2 text-blue-600 hover:text-blue-800 font-medium">
            展开
        </button>
    </div>
    <div class="box">
        <div>1</div>
        <div>2</div>
        <div>3</div>
    </div>
    <div class="box">
        <div>1</div>
        <div>2</div>
        <div>3</div>
    </div>
    <div class="box2">box2 scss</div>
    <div class="box3">box3 sass</div>

    <button id="btn">get</button>
    <p>
        线程同步启动!「20+年龄段」与「2024年」, 一起下班了。
        系统已成功升级至「3.0稳定版」,
        更新日志: 心态更稳，智慧++, 并修复了“过于年轻”的显示Bug。
        新地图「2025年」已加载完毕。欢迎进入我的三十岁!
    </p>
    <script>

        // const observer = new IntersectionObserver((box) => {
        //     console.log(box, 1)
        //     box.forEach(item => {
        //         if (item.isIntersecting && item.intersectionRatio === 1) {
        //             item.target.classList.add('red');
        //         }
        //     })

        // },
        //     {
        //         // 当元素可见比例达到 30%、50%、100% 时触发回调
        //         threshold: [0.3, 1],     // 默认值为 0（仅在元素刚进入视口时触发一次）
        //         root: null,  // 观察的跟元素， 必须是目标元素的祖先节点 监听元素在某个滚动容器内的可见性
        //         rootMargin: "100px 0px" // 根容器的扩展边距. , 元素进入视口前 100px 就触发回调
        //     }
        // )
        // const box = document.querySelectorAll('.box')
        // box.forEach(item => {
        //     observer.observe(item)
        // })

        document.addEventListener('DOMContentLoaded', () => {
            const textEl = document.getElementById('textContent');
            const btnEl = document.getElementById('toggleBtn');
            let isExpanded = false;
            // 切换展开/收起状态
            btnEl.addEventListener('click', () => {

                isExpanded = !isExpanded;

                if (isExpanded) {
                    textEl.classList.remove('clamped');
                    btnEl.textContent = '收起';
                } else {
                    textEl.classList.add('clamped');
                    btnEl.textContent = '展开';
                }
            });

            const channel = new BroadcastChannel('my-channel');
            document.getElementById('btn').onclick = function () {
                console.log(111111)
                channel.postMessage({
                    type: 'notice',
                    content: '新消息通知',
                    time: new Date().toLocaleTimeString()
                })
            }


            channel.onmessage = (event) => {
                if (event.data.type === 'notice') {
                    alert(`通知：${event.data.content}`);
                }
            };
            window.addEventListener('beforeunload', () => {
                channel.close();
            });

            function arrSet(arr) {
                const resultSet = new Set()
                const objSet = new Set()

                for (let i = 0; i < arr.length; i++) {
                    const item = arr[i]
                    if (item === null || typeof item !== 'object') {
                        resultSet.add(item)
                    } else {
                        let key = null
                        try {
                            key = JSON.stringify(item)
                        } catch {
                            key = item
                        }
                        if (!objSet.has(key)) {
                            objSet.add(key)
                            resultSet.add(item)
                        }

                    }
                }
                return [...resultSet]

            }
            console.log(arrSet(NaN, NaN, [1, 2], [1, 2], 1, null))

        });

        
    </script>
</body>

</html>